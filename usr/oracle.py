#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jul  6 06:48:29 2023

@author: chen
"""
# from xtb.interface import Calculator
# from xtb.utils import get_method
import numpy as np
# from xtb.utils import get_solvent
import time
import sys
import pickle
sys.path.append("../quantum_chem_python/")
import os
current_path = os.getcwd()
import re
from quantum_chem_python.api.settings import GeneralSettings, MultiProcessingSettings, XTBSettings, TurbomolSettings
from quantum_chem_python.api.turbomol.turbomol_api import TurbomolApi
from quantum_chem_python.api.xtb.xtb_api import XTBApi
from usr.utils import generate_xyz, reconstruct_from_metadata, convert_to_1d_float_array
from usr.initial_pyg.functions.config import ConfigLoader
import torch
import ast
import periodictable
import tempfile
import os

def create_unique_scratch_dir(rank):
    scratch_dir = os.path.join(tempfile.gettempdir(), f"oracle_scratch_{rank}")
    os.makedirs(scratch_dir, exist_ok=True)
    return scratch_dir

def atomic_number_to_symbol(atomic_numbers):
    return [periodictable.elements[num].symbol for num in atomic_numbers]
class UserOracle(object):
    """User defined oracle. Receive inputs from MG and generate ground truth."""
    def __init__(self, rank, result_dir):
        """
        Initilize the model.
        
        Args:
            rank (int): current process rank (PID).
            result_dir (str): path to directory to save metadata and results.
        """
        self.rank = rank
        self.result_dir = result_dir
        config = ConfigLoader("config.yaml")
        self.meta_data = config['metadata']
        self.prefix = config['prefix']
        self.work_path = os.getcwd()
        tmp = create_unique_scratch_dir(self.rank)
        self.out = tmp
        # self.out = f"{current_path}/results/{self.prefix}/test_output_{self.rank}"
        self.counter = 0
        self.fail = 0
        self.avg_time = 0
    def run_calc(self, input_to_orcl):
        """
        Run Oracle computation.
        Args:
            input_for_orcl (1-D numpy.ndarray): input for oracle computation.
                                                Source: element of input_to_orcl_list from utils.prediction_check()

        Returns:
            orcl_calc_res (1-D numpy.ndarray): results generated by Oracle.
                                               Destination: element of datapoints at UserModel.add_trainingset().
        """
        ##### User Part #####
        # print('input_to_orcl', len(input_to_orcl))
        print(f'rank {self.rank} running')
        
        input_to_orcl = reconstruct_from_metadata(input_to_orcl, self.meta_data)
        # print('input_to_orcl', input_to_orcl)
        atoms = atomic_number_to_symbol(input_to_orcl[1].tolist())
        # atoms_list = re.sub(r'\b(\w+)\b', r"'\1'", atoms)


        time1 = time.time()
        settings = GeneralSettings(mp_settings=MultiProcessingSettings(mp_active=False, number_of_workers=1),
                                output_dir_path=self.out,
                                input_file_path=f"{current_path}/results/{self.prefix}/test_output_{self.rank}",
                                delete_run_dir=True,
                                load_from_file=False,
                                coords=torch.tensor(input_to_orcl[0]),
                                elements=atoms)

        # xtb_settings = XTBSettings(binary_path="/home/yumeng/xtb-6.6.0/bin/xtb", charge= input_to_orcl[4], solvent = "Aniline", iterations = 500, accuracy = 500)
        # print('input_to_orcl[4]', input_to_orcl[4])

        turbomol_settings = TurbomolSettings(basis="dhf-TZVP ", 
                                            functional="tpss", 
                                            method="ridft",
                                            input_in_angstrom=True, 
                                            use_cosmo = True, 
                                            epsilon = 'infinity', 
                                            charge = input_to_orcl[4])


        # xtb_api = XTBApi(general_settings=settings, xtb_settings=xtb_settings)
        turbomol_api = TurbomolApi(general_settings=settings, turbomol_settings=turbomol_settings)

        # turbomol_api = TurbomolApi(general_settings=settings, turbomol_settings=turbomol_settings)
        try:

            
            xtb_energies, xtb_forces = turbomol_api.get_energy_and_gradient()
            input_to_orcl[2] = torch.tensor(xtb_energies)
            input_to_orcl[3] = torch.tensor(xtb_forces[0])  # gradient to force

            orcl_calc_res = np.concatenate([
                np.atleast_1d(xtb_energies),  # Ensure xtb_energies is a 1D array
                np.ravel(xtb_forces[0])       # Flatten the first element of xtb_forces
            ])

            self.shape = orcl_calc_res.shape
            time_finished = time.time()
            self.counter += 1
            time_used = time_finished - time1
            self.avg_time += time_used
            print(f'rank {self.rank} done in {time_used} seconds, {self.counter} labels with {self.shape} shape generated')

        except Exception as e:
            print('turbomoles failed')
            print(e)
            self.fail += 1
            os.chdir(self.work_path)
            print(input_to_orcl)
            orcl_calc_res = np.zeros(self.shape)
            print('orcl_calc_res', orcl_calc_res.shape, orcl_calc_res)
            fail = input_to_orcl
            fail[2] = None
            fail[3] = None
            # Save the 'fail' object to a file
            results_dir = './results'
            file_path = os.path.join(results_dir, 'xtbfail')
            mode = 'ab' if os.path.exists(file_path) else 'wb'

            # Save the 'fail' object to the file
            with open(file_path, mode) as f:
                pickle.dump(fail, f)
            time_finished = time.time()
            print(f'rank {self.rank} done, failed to generate labels set {self.shape} shape to None values,\n {self.fail} failed labels')
        # turbomol_energies = xtb_api.vibrational_analysis()

        #print("Time: ", time1 - time.time())
        # print("XTB Energies: ", xtb_energies)
        
        
        ##### User Part END #####
        return orcl_calc_res
    def stop_run(self):
        """
        Called before the Oracle process terminating when active learning workflow shuts down.
        """
        ##### User Part #####
        print(f'rank {self.rank} average time {self.avg_time/self.counter}')
        # add log for average time
        with open(f'results/{self.prefix}/execution_time.txt', 'a') as file:
            file.write(f"Average time for rank {self.rank}: {self.avg_time/self.counter} \n")

        ##### User Part END #####s